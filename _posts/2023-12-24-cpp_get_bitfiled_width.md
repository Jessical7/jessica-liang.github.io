---
layout: post
title: cpp_get_bitfield_width
date: 2023-12-24
tags: [c_cpp]
author: taot
---


## C++ 获取位域成员的位宽

C++ 中可以使用位域来节省内存，实现不同长度的数据的存放，例如：

```cpp
struct BF {
	uint32_t a1 : 4;
	uint32_t a2 : 5;
	uint32_t a3 : 6;
} bf;
```

结构体变量 bf 大小为 2 Byte，其成员变量 a1, a2, a3 分别占 4， 5， 6  位二进制，一共是 15 位 二进制，按照字节对齐，因此一个结构体变量 bf 占 2 字节。

C++ 支持这样的自定义数据结构，但是没有提供获取结构体变量 bf 的每个成员所占位宽的方法。

### 这里给出一种利用数据类型溢出的方法来获取这样的结构体的成员变量的位宽的方法：

以上面的结构体类型 BF 为例，它的成员变量都是无符号类型。由于无符号类型无法表示负数，当将无符号类型变量的值减小成负数的时候，就会发生溢出：

```cpp
uint32_t a = 0;
a -= 1;		// 此时由于无符号类型变量 a 变成了 -1， 但是无符号类型的范围不包含 -1，即此时 a 发生了溢出，由 uint32_t 的表示范围知道，此时溢出的 a 的值是 (1 >> 32) - 1，即 a 此时的值是 32 为全 1 二进制数，此时只需要计算出 a 的 1 的个数即可得到 a 的位宽
```

将上面的方法用在 bf 上就有：

```cpp
int len_a1 = bitset<64>(bf.a1 - (bf.a1 + 1)).count();	// 4
int len_a2 = bitset<64>(bf.a2 - (bf.a2 + 1)).count();	// 5
int len_a3 = bitset<64>(bf.a3 - (bf.a3 + 1)).count();	// 6
```

--> 上面的方法不仅适用于无符号类型的位域成员，对于有符号类型的位域成员也可以使用类似的方法，是需要改变是位域成员溢出为该类型最大整数的方法即可。